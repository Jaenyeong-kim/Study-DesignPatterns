# 소스 주의
Head First Design Patterns 책 소스이나 직접 타이핑 및 빌드 등으로
패키지, 클래스, 메소드 등에 이름이나 작성 알고리즘(문법 등)이 조금씩 다를 수 있음

## 객체 지향의 기초
1. 추상화
2. 캡슐화
3. 다형성
4. 상속

## 객체 지향의 원칙
* 바뀌는 부분을 캡슐화 한다.
* 상속보다는 구성을 활용한다.
* 구현이 아닌 인터페이스에 맞춰서 프로그래밍한다.
* 서로 상호작용을 하는 객체 사이에서는 가능하면 느슨하게 결합하는 디자인을 사용해야 한다.
* 클래스는 확장에 대해서는 열려있지만 변경에 대해서는 닫혀 있어야 한다.(OCP)
* 추상화된 것에 의존하라. 구상 클래스에 의존하지 않도록 한다.
* 친한 친구들하고만 이야기 한다.
* 먼저 연락하지 않기.
* 어떤 클래스가 바뀌게 되는 이유는 단 한가지 뿐이어야 한다.

## 패턴 요약

* 스트래티지 패턴 - 알고리즘군을 정의하고 각각을 캡슐화하여 바꿔 쓸 수 있게 만듭니다. 스트래티지 패턴을 이용하면 알고리즘을 활용하는 클라이언트와 독립적으로 알고리즘을 변경할 수 있습니다.

* 옵저버 패턴 - 한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체들한테 연락이 가고 자동으로 내용이 갱신되는 방식으로 일대다 의존성을 정의합니다.

* 데코레이터 패턴 - 객체에 추가 요소를 동적으로 더할 수 있습니다. 데코레이터를 사용하면 서브 클래스를 만드는 경우에 비해 훨씬 유연하게 기능을 확장할 수 있습니다.

* 추상 팩토리 패턴 - 서로 연관된, 또는 의존적인 객체들로 이루어진 제품군을 생성하기 위한 인터페이스를 제공합니다. 구상 클래스는 서브 클래스에 의해 만들어집니다.

* 팩토리 메소드 패턴 - 객체를 생성하기 위한 인터페이스를 만듭니다. 어떤 클래스의 인스턴스를 만들지는 서브 클래스에서 결정하도록 합니다. 팩토리 메소드를 이용하면 인스턴스를 만드는 일을 서브 클래스로 미룰 수 있습니다.

* 싱글턴 패턴 - 클래스 인스턴스가 하나만 만들어지도록 하고, 그 인스턴스에 대한 전역 접근을 제공합니다.

* 커맨드 패턴 - 요청 내역을 객체로 캡슐화하여 클라이언트를 서로 달느 요청 내역에 따라 매개변수화할 수 있습니다. 요청을 큐에 저장하거나 로그로 기록할 수도 있고 작업취소 기능을 지원할 수도 있습니다.

* 어댑터 패턴 - 클래스의 인터페이스를 클라이언트에서 요구하는 다른 인터페이스로 변환합니다. 인터페이스가 호환되지 않아 쓸 수 없었던 클래스들을 같이 사용할 수 있게 해 줍니다.

* 퍼사드 패턴 - 서브시스템에 있는 일련의 인터페이스에 대한 통합 인터페이스를 제공합니다. 퍼사드 패턴에서는 서브시스템을 더 쉽게 사용할 수 있게 해 주는 고수준 인터페이스를 정의합니다.

* 템플릿 메소드 패턴 - 어떤 작업 알고리즘의 골격을 정의합니다. 일부 단계는 서브 캘래스에서 구현하도록 할 수 있습니다. 템플릿 메소드를 이용하면 알고리즘의 구조는 그대로 유지하면서 특정 단계만 서브 클래스에서 새로 정의하도록 할 수 있습니다.

* 이터페이터 패턴 - 컬렉션을 표현하는 방법을 노출시키지 않으면서도 집합체 내에 있는 모든 객체들에 하나씩 접근하는 방법을 제공합니다.

* 컴포지트 패턴 - 객체들을 트리 구조로 구성하여 부분-전체 계층구조를 구현합니다. 컴포지트 패턴을 이용하면 클라이언트에서 개별 객체와 복합 객체를 똑같은 방법으로 다루도록 할 수 있습니다.

* 스테이트 패턴 - 내부 상태가 바뀜에 따라 객체의 행동이 바뀔 수 있도록 해 줍니다. 마치 객체의 클래스가 바뀌는 것 같은 결과를 얻을 수 있습니다.

* 프록시 패턴 - 다른 객체를 대변하는 객체를 만들어서 주 객체에 대한 접근을 제어할 수 있습니다.

* 컴파운드 패턴 - 두 개 이상의 패턴을 결합하여 일반적으로 자주 등장하는 문제들에 대한 해법을 제공합니다.

